; LISP test file
;
;;;;;;;;;  reminder to staff: do NOT edit this file by hand.
;                             it was generated automatically.
;

; for a specific part, to test everything interactively:
;    -- enter clisp:
;          clisp -q -i ../init.lsp
;       note: ../init.lsp is in Given
;             it includes
;                (setq *print-case* :downcase)
;             Output.correct was generated using that.
;    -- use one of the ty functions to test everything
;       for example, in part 1, give the command:
;          (ty1)
;    -- exit clisp
;          (quit)   or   ^D
;    -- compare your output vs. correct output:
;          diff Output.correct Output.your
;       or
;          tkdiff Output.correct Output.your
;       files should be identical except timestamps on 2 "Dribble..." lines.
;
; NB:  clisp output formatting takes into account the number of columns
; in your window.  The Output.correct file was generated
; for 80 column output.  Your output may differ for different sized windows.
; It's okay if your output is the same except for whitespace formatting
; (but easier, so you can use diff, if you run in an 80 column window).
;
; you might find some of the other functions below helpful in your testing
; e.g., to test all of part2 (and all of part1)
;       w/o writing to Output.your, use
;          (test-part2)
; e.g., to test only all of part2 but none of part1
;        w/o writing to Output.your, use
;          (test-only-part2)

(defun testOneSaveOutput (testPartFunction)
	(saveOutputBegin)
	(testOne testPartFunction)
	(saveOutputEnd)
)
(defun testOne (testPartFunction)
	(format t "~%~10TBEGIN TESTING~2%")
	(funcall testPartFunction)
        (format t "~%~10TDONE TESTING~2%")
	t
)

; delete-file is needed because some clisps (e.g., the one on Linux PC)
; append rather than truncate when dribbling to an existing file.
(defun saveOutputBegin ()
        (delete-file "Output.your")
	(dribbleNoTimeStamp "Output.your")
)
(defun saveOutputEnd ()
	(dribbleNoTimeStamp)
)


;;;; modified from clisp-2.49/src/dribble.lisp
;;;;
;;;; as name suggests, doesn't output timestamp
;;;; so that diff doesn't complain about different timestamps.
;;;;
;;;; since original dribble is in SYSTEM and this dribble isn't,
;;;; needed to add a few SYSTEM:: for some functions.
;;;;    (I might have missed some.)
;;;;    (would need on date-string if used that again.)

;;;; Dribble

(defun dribbleNoTimeStamp-toggle (stream &optional file)
  (multiple-value-bind (source target) (dribble-stream stream)
    (if source
      (if file                  ; already dribbling
        (warn (SYSTEM::TEXT "Already dribbling ~S to ~S") source target)
        (progn
          ;;(format target (TEXT "~&;; Dribble of ~S finished on ~A.~%")
          ;;        source (date-string))
          (format target (SYSTEM::TEXT "~&;; DribbleNoTimeStamp of ~S finished.~%")
                  source)
          (values source target)))
      (if file                    ; not dribbling
        (let ((target
               (if (and (streamp file)
                        (open-stream-p file) (output-stream-p file))
                 file
                 (open file :direction :output
                            :external-format (stream-external-format stream)
                            :if-exists :append
                            :if-does-not-exist :create))))
          ;;(format target (SYSTEM::TEXT ";; DribbleNoTimeStamp of ~S started on ~A.~%")
          ;;        stream (date-string))
          (format target (SYSTEM::TEXT ";; DribbleNoTimeStamp of ~S started.~%")
                  stream)
          (values (make-dribble-stream stream target) target))
        (warn (SYSTEM::TEXT "Currently not dribbling from ~S.") stream)))))

(defun dribbleNoTimeStamp (&optional file)
  (multiple-value-bind (source target) (dribbleNoTimeStamp-toggle *terminal-io* file)
    (when (streamp source)         ; no warning
      (unless file (close target)) ; dribble off
      (setq *terminal-io* source))
    target))
; part tests (each tests all previous parts and all in this part)
; output saved to a file
(defun ty1 ()
	(saveOutputBegin)
	(test-part1)
	(saveOutputEnd)
)
(defun ty2 ()
	(saveOutputBegin)
	(test-part2)
	(saveOutputEnd)
)
(defun ty3 ()
	(saveOutputBegin)
	(test-part3)
	(saveOutputEnd)
)
(defun ty4 ()
	(saveOutputBegin)
	(test-part4)
	(saveOutputEnd)
)
(defun ty5 ()
	(saveOutputBegin)
	(test-part5)
	(saveOutputEnd)
)
(defun ty6 ()
	(saveOutputBegin)
	(test-part6)
	(saveOutputEnd)
)
(defun ty7 ()
	(saveOutputBegin)
	(test-part7)
	(saveOutputEnd)
)
(defun ty8 ()
	(saveOutputBegin)
	(test-part8)
	(saveOutputEnd)
)
(defun ty9 ()
	(saveOutputBegin)
	(test-part9)
	(saveOutputEnd)
)
; part tests (each tests all previous parts and all in this part)
(defun test-part1 () (test-only-part1))
(defun test-part2 ()
	(test-part1)
	(test-only-part2)
)
(defun test-part3 ()
	(test-part2)
	(test-only-part3)
)
(defun test-part4 ()
	(test-part3)
	(test-only-part4)
)
(defun test-part5 ()
	(test-part4)
	(test-only-part5)
)
(defun test-part6 ()
	(test-part5)
	(test-only-part6)
)
(defun test-part7 ()
	(test-part6)
	(test-only-part7)
)
(defun test-part8 ()
	(test-part7)
	(test-only-part8)
)
(defun test-part9 ()
	(test-part8)
	(test-only-part9)
)
; some shorthands, so that you can just type, e.g., (tp1)
(defun tp1 () (test-part1))
(defun tp2 () (test-part2))
(defun tp3 () (test-part3))
(defun tp4 () (test-part4))
(defun tp5 () (test-part5))
(defun tp6 () (test-part6))
(defun tp7 () (test-part7))
(defun tp8 () (test-part8))
(defun tp9 () (test-part9))
(defun top1 () (test-only-part1))
(defun top2 () (test-only-part2))
(defun top3 () (test-only-part3))
(defun top4 () (test-only-part4))
(defun top5 () (test-only-part5))
(defun top6 () (test-only-part6))
(defun top7 () (test-only-part7))
(defun top8 () (test-only-part8))
(defun top9 () (test-only-part9))
; part specific tests
(defun test-only-part1 () (test-cross1))
(defun test-only-part2 () (test-cross2))
(defun test-only-part3 () (test-my-every))
(defun test-only-part4 () (test-flatp))
(defun test-only-part5 () (test-lenLFL))
(defun test-only-part6 () (test-legalcondp))
(defun test-only-part7 () (test-rewrite))
(defun test-only-part8 () (test-check))
(defun test-only-part9 ()
	(test-rewrite-ite)
	(test-check-ite)
)
; some abbreviations, so that you can just type, e.g., (tc1)
(defun tc1 () (test-cross1))
(defun tc2 () (test-cross2))
(defun te () (test-my-every))
(defun tf () (test-flatp))
(defun tF () (test-lenLFL))
(defun tl () (test-legalcondp))
(defun tw () (test-rewrite))
(defun tc () (test-check))
(defun tx () (test-rewrite-ite))
(defun td () (test-check-ite))
; test all the cross1 functions
(defun test-cross1 ()
        (format t "~%~20TTEST-CROSS1~2%")
        (test-cross1-recursive)
        (test-cross1-iterative)
        (test-cross1-mapcar)
        t
)
(defun test-cross1-recursive ()
        (test-a-cross 'cross1-recursive)
        t
)
(defun test-cross1-iterative ()
        (test-a-cross 'cross1-iterative)
        t
)
(defun test-cross1-mapcar ()
        (test-a-cross 'cross1-mapcar)
        t
)

; test all the cross2 functions
(defun test-cross2 ()
        (format t "~%~20TTEST-CROSS2~2%")
        (test-cross2-recursive)
        (test-cross2-iterative)
        (test-cross2-mapcar)
        t
)
(defun test-cross2-recursive ()
        (test-a-cross 'cross2-recursive)
        t
)
(defun test-cross2-iterative ()
        (test-a-cross 'cross2-iterative)
        t
)
(defun test-cross2-mapcar ()
        (test-a-cross 'cross2-mapcar)
        t
)

; tests the cross function cross-fun.
; prints out cross-fun instead of actual name,
; e.g., (cross-fun nil nil) instead of (cross1-recursive nil nil)
;
(defun test-a-cross (fun)
        (format t "~%~30TTEST-A-CROSS on:  ~A~2%" fun)
        (defun cross-fun (x y) (funcall fun x y))
        (tester '(cross-fun 88 99) )
        (tester '(cross-fun 88 nil) )
        (tester '(cross-fun nil 99) )
        (tester '(cross-fun '(1) 99) )
        (tester '(cross-fun nil nil) )
        (tester '(cross-fun '(1) nil) )
        (tester '(cross-fun nil '(a)) )
        (tester '(cross-fun '(1) '(a)) )
        (tester '(cross-fun '(1) '(a b)) )
        (tester '(cross-fun '(1 2) '(a)) )
        (tester '(cross-fun '(1 2) '(a b)) )
        (tester '(cross-fun '(1 2 3) '(a b)) )
        (tester '(cross-fun '(1 2) '(a b c)) )
        t
)

(defun test-my-every ()
        (format t "~%~20TTEST-MY-EVERY~2%")
        (tester '(my-every #'listp '()))
        (tester '(my-every #'listp '(1)))
        (tester '(my-every #'listp '(1 2)))
        (tester '(my-every #'listp '(1 2 3)))
        (tester '(my-every #'integerp '()))
        (tester '(my-every #'integerp '(1)))
        (tester '(my-every #'integerp '(1 2)))
        (tester '(my-every #'integerp '(1 2 3)))
        (tester '(my-every #'integerp '(1 a 2)))
        (tester '(my-every #'integerp '(a 1 2)))
        (tester '(my-every #'integerp '(1 2 a)))
        (tester '(my-every #'(lambda (a) (> a 4)) '(5 6 9)))
        (tester '(my-every #'(lambda (a) (> a 4)) '(5 6 0 9)))
        t
)

(defun test-a-flat (fun)
        (format t "~%~30TTEST-A-FLAT on:  ~A~2%" fun)
        (defun flat-fun (x) (funcall fun x))
        (tester '(flat-fun '()) )
        (tester '(flat-fun '(())) )
        (tester '(flat-fun '(1)) )
        (tester '(flat-fun '(1 2)) )
        (tester '(flat-fun '(1 2 3)) )
        (tester '(flat-fun '(1 nil 2 nil 3)) )
        (tester '(flat-fun '(1 (2) 3)) )
        (tester '(flat-fun '((1 a b) (2) 3)) )
        (tester '(flat-fun '((1 2) 3 4 5 6 7 8) ) )
        (tester '(flat-fun '(0 (1 2) 3 4 5 6 7 8) ) )
        (tester '(flat-fun '(0 1 2 3 4 (5 6 7 8)) ) )
        (tester '(flat-fun '((1 a b) (2 c d e) 3 5 (6 7 8 fds a) 99)) )
        (tester '(flat-fun '((1 a b) (2 c (w o n d e r - d o g) e) 3 5 (6 7 8 fds a) 99)) )
        (tester '(flat-fun '((((1 nil 2 nil 3)))) ) )
        (tester '(flat-fun '((((((1)))))) ) )
        (tester '(flat-fun '((((((1)) (222 223))))) ) )
        (tester '(flat-fun '((((((1 2 3 4)))))) ) )
        t
)

(defun test-flatp ()
        (format t "~%~20TTEST-flatp~2%")
        (test-a-flat 'flatp)
        t
)

(defun test-lenLFL ()
        (format t "~%~20TTEST-lenLFL~2%")
        (test-a-flat 'lenLFL)
        t
)

(defun test-legalcondp ()
        (format t "~%~20TTEST-LEGALCONDP~2%")
        (test-a-later 'legalcondp)
        t
)

(defun test-rewrite ()
        (format t "~%~20TTEST-REWRITE~2%")
        (test-a-later 'rewrite)
        t
)
(defun test-rewrite-ite ()
        (format t "~%~20TTEST-REWRITE-ITE~2%")
        (test-a-later 'rewrite-ite)
        t
)
(defun test-check ()
        (format t "~%~20TTEST-CHECK~2%")
        (test-a-later 'check)
        t
)
(defun test-check-ite ()
        (format t "~%~20TTEST-CHECK-ITE~2%")
        (test-a-later 'check-ite)
        t
)


; test a later part of the HW
(defun test-a-later (fun)
        (format t "~%~30TTEST-A-LATER on:  ~A~2%" fun)
        (defun later-fun (y) (funcall fun y))
        (tester '(later-fun nil  ))
        (tester '(later-fun 3  ))
        (tester '(later-fun '(list 1 2 3 4)  ))
        (tester '(later-fun '(cond nil)  ))
        (tester '(later-fun '(cond 3)  ))
        (tester '(later-fun '(cond 3 4)  ))
        (tester '(later-fun '(cond (3 4))  ))
        (tester '(later-fun '(cond (3))  ))
        (tester '(later-fun '(cond (3 4) 5)  ))
        (tester '(later-fun '(if 3 4 5) ))
        (tester '(later-fun '(if 3 4 (if 5 6)) ))
        (tester '(later-fun '(if nil 4 (if 5 6)) ))
        (tester '(later-fun '(cond (3 4 5)) ))
        (tester '(later-fun '(cond (1) (2) (3 4 5) (6)) ))
        (tester '(later-fun '(cond notlist) ))
        (tester '(later-fun '(cond (nil 3) notlist) ))
        (tester '(later-fun '(cond ((+ 1 22) 3) notlist) ))
        (tester '(later-fun '(cond (nil 3) (4)) ))
        (tester '(later-fun '(cond (3 4) (5))  ))
        (tester '(later-fun '(cond (3 4) 5 (6))  ))
        (tester '(later-fun '(cond (3 4) nil (6))  ))
        (tester '(later-fun '(cond (3 4) (t 5)) ))
        (tester '(later-fun '(cond ((= 3 4) 11) (t 15)) ))
        (tester '(later-fun '(cond ((= 3 3) 11) (t 15)) ))
        (tester '(later-fun '(cond ((= 3 4) 11) ((= 5 6) 12) (t 17)) ))
        (tester '(later-fun
			'(list (cond ((= 8 8) 'y)) (cond ((= 8 7) 'no)))) )
        (tester '(later-fun '(* 44 (cond (3 2) (5)))  ))
        (tester '(later-fun '(* 44 (cond (3 2) (t 5)))  ))
        (tester '(later-fun '(* 44 (cond (nil 7) (10)))  ))
        (tester '(later-fun '(* 44 (cond (nil 7) (t 10)))  ))
        (tester '(later-fun '(cond ((cond (3 8) (t 9)) 4) (t 5)) ))
        (tester '(later-fun '(cond ((cond (3 8) 9) 4) (t 5)) )) ; bad
        (tester '(later-fun '(cond (nil 4) (t 5))  ))
        (tester '(later-fun '(* 44 (cond (3 2) (t 5))) ))
        (tester '(later-fun '(* 44 (cond (nil 7) (t 10))) ))
        (tester '(later-fun '(* 44 (cond (nil 7)
                                         (t (cond (1) (2) (3 4 5) (6))))) ))
        (tester '(later-fun '(cond ((= 8 (cond (3 8) (t 9))) 4) (t 5)) ))
        (tester '(later-fun '(cond ((= 8 (cond (nil 8) (t 9))) 4) (t 5)) ))
        (tester '(later-fun '(cond ((= 8 (cond
                                               (3 (cond ((= 7 7) 8) (t 1)))
                                               (t 9)
                                          )
                                     ) 4)
                                    (t 5)
                             ) ))
        (tester '(later-fun '(cond ((= 8 (cond
                                               (3 (cond ((= 7 6) 8) (t 1)))
                                               (t 9)
                                          )
                                     ) 4)
                                    (t 5)
                             ) ))
        (tester '(later-fun '(cond ((= 8 (cond
                                               (3 (cond ((= 7 6) 8)
                                                        ((cond ((+ 1 22) 3)
                                                              (t 77)))))
                                               (t 9)
                                         )
                                     ) 4)
                                    (t 5)
                             ) ))
        (tester '(later-fun '(cond ((= 8 (cond
                                               (3 (cond ((= 7 6) 8)
                                                        ((cond ((+ 1 22) 3)
                                                               notlist))))
                                               (t 9)
                                          )
                                     ) 4)
                                    (t 5)
                              ) ))
        (tester '(later-fun '(cons (cond ((= 8 7) 'bad) (t 'good))
                                    (cond ((= 8 7) 'nope) (t 'yup))
                             )
                 )
        )
        (tester '(later-fun '(list (cond ((= 8 7) 'bad))
                                    (cond ((= 8 7) 'nope))
                             )
                 )
        )
        (tester '(later-fun '(list (cond ((= 8 8) 'yes))
                                    (cond ((= 8 8) 'okay))
                             )
                 )
        )
        (tester '(later-fun '(list (cond ((= 8 8) 'yes))
                                    (cond ((= 8 7) 'nope))
                             )
                 )
        )

	t
)


; low-level testing routine
(defun tester (x)
        (format t "testing:  ~A~%" x)
        ; split into 2 so print value even if eval fails.
        (format t "value:    ")
        (format t "~A~2%" (eval x))
        t
)
